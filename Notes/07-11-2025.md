## 7th of November

## Questions

- Garbage collection. Should we force gc after step? When is it safe to do? When can a node be deleted?
- I still don't quite fully understand the `trig` constructor. In the paper it reads as if it's supposed to be able to help us create signals from "maybe A" signals (as seen in the filter example). But `trig` creates something of type `Later(A)`, that is a single value of type `A` at a later time. Is the runtime supposed to have a `mkSig_from_oe` that treats such trips as repeated?
	- **Answer** => think of it as a channel on "internal signals". 
- Garbage collection? Should we force it? When can/can't we do it?
	- Little unfair with no code, but if we do not force a GC - then signals with side effects will do them too many times... and it sort of explodes our heap.
	- **Answer** => GC at inconvenient times is a consequence of the language choice, automatic reference count would have been "smarter".
		- Program should behave the same whether or not GC is called.
		- Problem is the call to print_endline - no side effects in our tails!
- **Tail semantics** => should be evaluated once, even if used in multiple signals

## Observation ?

We have this weird need for deletion in the heap.step_cursor. We are able to remove the delete if we instead of using the `v'.tail` we wrap the signal with `tail sv2`. In that case the program will behave correctly, but the heap will grow and garbage collection won't collect extra signals from the heap. The call `tail sv2` creates an object with a reference to `sv2` which can then never be garbage collected.

```ml
    else
      let sv2 = advance k v2 v in
      let v' = signal_get_data sv2 in
      update heap.cursor v'.head (tail sv2);
      cursor_data.updated <- true;
      incr_cursor ()
```

And the version with a delete looks like:

```ml
    else
      let v' = signal_get_data (advance k v2 v) in
      (* TODO: Figure out why this is necessary *)
      let _ = match find v'.id with 
      | None -> failwith ("Heap.step_cursor: advanced signal not found in heap for id " ^ string_of_int v'.id)
      | Some n -> delete n in
      update heap.cursor v'.head v'.tail;
      cursor_data.updated <- true;
      incr_cursor ()
```