# notes 10 oct 2025

(* does not impliment the semantics precisely? *) These are just sketches.
(* head is missing *)

(* make later a GAT *)

## Heap

needs to be some kind of mutable linked list. The point of being mutable is the values needs to be able to change when the value changes from a time tick. Also is for the creation of new items in the heap.

we allocate at the now breaking point

Head is at the now and has a breaking point at some point. After the break we will have a earlier heap, which can be discarded at the next time step.

Values needed: (weak references are needed to avoid memory leaks)
- label (name)
- head pointer
- tail pointer
- bool
<!-- - breaking point pointer (cursor) -->

Items:
- last item reference
- next item reference
- value

signal needs to have a value, tail and a bool (has been updated)

signal "name" counter
and channel "name" counter (only has the name as it can be considered a port like in IP protocol)

## Advance semantics

channel something use obj magic 



## update semantics

use trigged to check if a signal in the heap has trigged. If it has then call advance on it and set the flag to true.


### we might want to generalize wait to only make a' an int



## heap

we get an input on the channel k, with value int.

Then look in the head of the earlier heap for the signal with the name k. 

if it has ticked then advance the signal and set the bool to true.

when something new comes we set the curser to the head. Then we go through the heap and update everything one after each other.

If values have been garbage collected then we can remove them from the heap.
