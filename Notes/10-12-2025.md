## Notes


- Async language => async fecth, synchronous action. Step is synchronised, so unless they depend on the same channel (anywhere in the chain), they will never tick on the same step.
	- Asynchronous => in the sense that 2 singles are not necessarily synchronised.
	- A paragraph saying that "oh by the way, the signals are asynchronous" . We could quickly introduce the sync.
- Mult2 => the goal was to show $head \; xs$ is valid because $xs$ is a reference. A convoluted multiplication $x + x \dots$.
	- Overall, weird. slam 2 points together in the same example. Probably split the example in two.
- Example of using Rizzo => why not just slap the types on everything?:
	- Easiest thing would be to create a figure with all the relevant functions. 
- Finish the Rizzo graph :)
- The Rizzo paper is live on bahr.io, so we can reference it.
- Maybe fine, to have a stop clock function
	- Could be done without a thread => we know which signals are waiting on a clock. If there something waiting on the clock, start the timer. And do it again next time someone is waiting for the timer.
	- We tried this with the exact wake up - could we mention that in the report.
	- Might be question at the defence.
- Weak reference counting => 
	- Should we move GC to before the inner call - tehe.
- 2.2 => it is okay to reference forward, that the need for weak reference + reference counting comes later.
- Related literature => 
	- We need to show that we are not unaware of other stuff
	- Recommendation => could be FRP as a library: *Yampa*, *FRPNow!*, and async rattus work (and also cite that). 
- Exam: 6th of january
