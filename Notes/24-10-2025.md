# 24th of October 2025

##### Questions
- **What happens in `advance` semantics for `Trig` when the update-flag is not set to updated?**
	- That is a failure, the advance should only be called when the flag is set to true. This is result of the update rule that checks if ticked(v) and ticked for a trig, is only true if the update flag is set to true. TL:DR that is a crash, a bug is somewhere. 
- **Ticked for tail splits the heap in $N_1,\ell,N_2$. Is it important that we only consider part of the heap before it?**
	- Say $\ell$ is somewhere in the middle of the heap. Are only allowed to consider from start to $\ell$ when trying to determine if $w$ ticked?
	- Answer => doesn't matter for our implementation, it is there to make the proofs go through.
- **What does the infrastructure for channels look like**
	- Create baked-in channels (a cmd-line one and another for "time" that steps after some time).
		- Patrick will send an example, in the asynchronous FRP in haskell
		- Minimal viable / **Goal of the project**: could be having these channels, that we send input down.
		- In principle just have these as global variables, have some asynchronous code somewhere that looks for console input/or time to pass(?) then use step semantics on the correct channel.
		- "Something fun" => having well-typed channels at run-time
			- Channel is an structure of both our channel and a function (a producer which is a blocking-function)
			  {chan:'a channel; prod: () -> 'a }
