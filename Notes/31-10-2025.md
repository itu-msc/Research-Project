# 31st of October, 2025

## Questions

- For something like `setOutput`, how are we supposed to run something when something is stepped?
  - `setOutput` for example says it takes a signal and a producer function. So when the signal head updates, how are we supposed to run the producer function?
- Should it be possible to read a value from a signal multiple times in the same tick?
  - For example, if we have a signal `s` and we read its value twice in the same tick, should we get the same value both times?
  - Or should we get an error if we try to read it multiple times in the same tick?
- How should we be doing the clock?
  - Do we need to make it in a new thread?
  - If so, do we need to set a mutex on the step function?

- could we double check if the generic channel implementation looks good?


## Notes

- we should consider time as instants, so in between "step" on any channel the head of a signal is the same for "instant".
- Clock => We need to be careful in our "Rizzo" runtime, i.e. managing the clocks etc.
	- The library-user side vs. our implementation side.
	- Semantics are defined without concurrency. It is meant to be declarative, used in a single thread.
	- User should never use step. => Steps are atomic. Only a step at a time, and so are reads.
- Runtime =>
	- "I constructed a bunch of signals", then a user asks the runtime to do something with the signal. Like plugging into a "console output" that the runtime maintains. (is that correct)?
	- "here is a bunch of input channels" => users does some signals => user commits their signals to some predefined outputs
	- Figure 4 => Async Rattus paper. No steps in user space, the "signals" are committed to "intOutput" etc.
- Consider mailbox pattern for channels/signals?