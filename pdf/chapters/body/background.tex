\section{Using Rizzo} \label{using_rizzo}
%user space, examples of how to use it?
%Input channels : Clock signals, console signal, 
%Output "channels":

To give some insight into how Rizzo can be used, we will in this section present a small example program that uses Rizzo to implement a simple interactive application. The application will read input from the console and a network port, and will output values to the console and the network port based on the input it receives.

First we need to open the Rizzo modules that we will use in our program. In this case we will use the \texttt{Types}, \texttt{Signal} and \texttt{Channel} modules.

\begin{lstlisting}
open Rizzo.Types
open Rizzo.Signal
open Rizzo.Channel
\end{lstlisting}

Now that we have access to the Rizzo modules, we can start implementing our application. The application will need to read input from the console and a network port. From the \texttt{Channel} module we can get a console input channel and a port input channel.

\begin{lstlisting}
let console_channel = console_input () in
let port_channel = port_input 9000 in
...
\end{lstlisting}

Using the channels, we can create signals that represent the input from the console and the network port.

\begin{lstlisting}
let console_out_signal = mkSig_of_channel console_channel in
let port_out_signal = mkSig_of_channel port_channel in
...
\end{lstlisting}

If we simply wanted to output the input signals directly to the console, we only need to use the \texttt{console\_outputD} function from the \texttt{Channel} module to output the signals. \texttt{console\_outputD} takes a later signal as input, where the D indicates that the signal is of a later type.

\begin{lstlisting}
console_outputL (console_out_signal);
console_outputL (port_out_signal);
\end{lstlisting}

However, to demonstrate the use of signal combinators in Rizzo, we will modify the output signals to prepend a string to the input values before outputting them to the console. We can use the \texttt{mapL} function from the \texttt{Signal} module to achieve this. \texttt{mapL} takes a function and a later signal as input, and applies the function to each value of the signal.

\begin{lstlisting}
console_outputL (mapL (fun s -> "From console: " ^ s) console_out_signal);
console_outputL (mapL (fun s -> "From port: " ^ s) port_out_signal);
\end{lstlisting}

Given we have not made a client that writes to the port, the port output will not produce any output, so lets fix that by taking the input from the console and writing it to the port as well. We can use the \texttt{port\_outputD} function from the \texttt{Channel} module to output to the port.

\begin{lstlisting}
port_send_outputL Unix.inet_addr_loopback 9000 console_out_signal;
\end{lstlisting}

To get it to run and block the main thread, we call \lstinline{start_event_loop ();} at the end of the program.

An example interaction with the program so far could look like this:

\begin{verbatim}
Hello Rizzo
From console: Hello Rizzo
From port: Hello Rizzo
Hello again
From console: Hello again
From port: Hello again
\end{verbatim}
\footref{appendix:simple_program}

Lets make it a bit more interesting by adding some more complex behaviour. We will add a clock signal that ticks every second, and a conditional that when input is received from the console, only prints if the current seconds that have passed are an even number.

We can create a clock signal using the \texttt{clock\_signal} function. The \texttt{clock\_signal} function takes a float as input, which represents the interval in seconds between each tick of the clock.

\begin{lstlisting}
let every_second, every_second_stop = clock_signal 1.0 in
\end{lstlisting}

% We can then create a signal that counts the number of ticks that have passed using the \texttt{scan} function. The \texttt{scan} function takes a function, an initial value, and a signal as input. \texttt{scan} then produces a new signal by applying the function to the last value and the current value of the input signal.

% \begin{lstlisting}
% let nats init = scan (fun n _ -> n + 1) init every_second in
% \end{lstlisting}

To implement the conditional behaviour, we can use the \texttt{filter} function to create a signal that only passes through values when input is received from the console. 

\todo{Finish this :)}

\subsection{Inputs}
Input sources in Rizzo are called channels. There can theoretically be implemented an input channel for any kind of input source, but currently Rizzo only has a console, clock and port input implementation.

To use one of the input channels, the user requests to get one of the channels from Rizzo, and then uses the channel to create signals. For example, bellow we show how a console input channel can be used to create a signal that represents the input from the console.

\begin{lstlisting}
open Rizzo
let console_channel = Channel.console_input () in
let console_signal = Signal.from_channel console_channel
\end{lstlisting}

\subsection{Signal operators}

\subsection{Outputs}

%Concepts, types, 
\section{Implementing Rizzo} \label{section:implementing_rizzo}

Rizzo is implemented in \texttt{Ocaml}, because it has weak references, generalized algebraic data types (GADTs) and a strong type system. We could potentially have better performance if we chose a language with reference counting, but Ocaml is a good trade-off between performance and expressiveness.
We have implemented Rizzo as a library, so we could draw a line between the core implementation and the user space. The intention with making this distinction is \texttt{if users follow our APIs}, then they should not be able to shoot themselves in the foot. If they don't they could potentially break the guarantees Rizzo provides, by introducing side effects. As an Ocaml library we cant guarantee that users will not introduce side effects, so we have to trust that they will follow the APIs.

\todo{add stuff about space/time leaks}

\subsection{Channels}
\todo{Make sure that we have explained what clocks and ticks are before this.}
Channels are input sources to Rizzo programs, and can be considered to be  associated with a clock. Each tick of the channel's clock represents an input event on the channel.
\todo{There is only one clock}

\todo{associate this with a diagram of some kind that shows the flow of data from channels -to- signals -to- output signals.}


\subsection{The delayOnce type}
The delayOnce type is used to represent values that will be available at the second time step, if the first time step is the creation of the type.

\subsection{The Later type}
The Later type is used to represent values that will be available at a later time step. In contrast to delayOnce, the Later type does not guarantee that the value will be available at the next time step, but only at some later time step. For example, using a filter on a signal will produce a signal that does not guarantee a value at the next time step, since the filter may not pass any values through.

\todo{Insert an example that shows how a map will also not guarantee a value if the filter has not met its condition yet.}

\subsection{Signals}
Signals are the core concept in Rizzo, and represent time-varying values. Signals can be constructed from channels, or from other signals using signal combinators.
Signals are implemented as an infinite sequence, with the head being the current value of the signal, and the tail being a new later signal of the same type.

For a reader unfamiliar with FRP, the signals can be considered a pipes where values flow through the network and ends up at output signals.


% \clearpage

% \subsection{A simpler processor model}\label{processor-model}
