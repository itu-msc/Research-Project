\section{FRP in Rizzo}\label{background}
%advance, step, advance semantics.

%Concepts, types, 
\section{Implementing Rizzo}

Rizzo is implemented in \texttt{Ocaml}, because it has weak references, generalized algebraic data types (GADTs) and a strong type system. We could potentially have better performance if we chose a language with reference counting, but Ocaml is a good trade-off between performance and expressiveness.
We have implemented Rizzo as a library, so we could draw a line between the core implementation and the user space. The intention with making this distinction is \texttt{if users follow our APIs}, then they should not be able to shoot themselves in the foot. If they don't they could potentially break the guarantees Rizzo provides, by introducing side effects. As an Ocaml library we cant guarantee that users will not introduce side effects, so we have to trust that they will follow the APIs.

\subsection{The \laterA{} type}


% \laterE for asynchronous delays and \laterA for a delay on the global clock

\subsection{The \laterE{} type}

\subsection{Channels}
\subsection{Signals}
%the type and how to construct these
% You cannot have a headless signal 
\subsection{The heap}
%Conceptually, how the heap should work

\section{Rizzo Core private methods}
%The core, whatever "glues" the concepts together, making it a language

\subsection{Heap implementation}
%Stuff like step, advance, 
%Concrete implementation, why a linked list? Why weak reference etc. Also the "alloc" to create signals.

\section{Using Rizzo}
%user space, examples of how to use it?
%Input channels : Clock signals, console signal, 
%Output "channels":

% \clearpage

% \subsection{A simpler processor model}\label{processor-model}



