\section{Using Rizzo} \label{using_rizzo}
%user space, examples of how to use it?
%Input channels : Clock signals, console signal, 
%Output "channels":

To give some insight into how Rizzo can be used, we will in this section present a small example program that uses Rizzo to implement a simple interactive application. The application will read input from the console and a network port, and will output values to the console and the network port based on the input it receives.

First we need to open the Rizzo modules that we will use in our program. In this case we will use the \texttt{Types}, \texttt{Signal} and \texttt{Channel} modules.

\begin{lstlisting}
open Rizzo.Types
open Rizzo.Signal
open Rizzo.Channel
\end{lstlisting}

Now that we have access to the Rizzo modules, we can start implementing our application. The application will need to read input from the console and a network port. From the \texttt{Channel} module we can get a console input channel and a port input channel.

\begin{lstlisting}
let console_channel = console_input () in
let port_channel = port_input 9000 in
...
\end{lstlisting}

Using the channels, we can create signals that represent the input from the console and the network port.

\begin{lstlisting}
let console_signal = from_channel console_channel in
let port_signal = from_channel port_channel in
...
\end{lstlisting}

\todo{Finish this :)}

\subsection{Inputs}
Input sources in Rizzo are called channels. There can theoretically be implemented an input channel for any kind of input source, but currently Rizzo only has a console, clock and port input implementation.

To use one of the input channels, the user requests to get one of the channels from Rizzo, and then uses the channel to create signals. For example, bellow we show how a console input channel can be used to create a signal that represents the input from the console.

\begin{lstlisting}
open Rizzo
let console_channel = Channel.console_input () in
let console_signal = Signal.from_channel console_channel
\end{lstlisting}

\subsection{Signal operators}

\subsection{Outputs}

%Concepts, types, 
\section{Implementing Rizzo} \label{section:implementing_rizzo}

Rizzo is implemented in \texttt{Ocaml}, because it has weak references, generalized algebraic data types (GADTs) and a strong type system. We could potentially have better performance if we chose a language with reference counting, but Ocaml is a good trade-off between performance and expressiveness.
We have implemented Rizzo as a library, so we could draw a line between the core implementation and the user space. The intention with making this distinction is \texttt{if users follow our APIs}, then they should not be able to shoot themselves in the foot. If they don't they could potentially break the guarantees Rizzo provides, by introducing side effects. As an Ocaml library we cant guarantee that users will not introduce side effects, so we have to trust that they will follow the APIs.

\todo{add stuff about space/time leaks}

\subsection{Channels}
\todo{Make sure that we have explained what clocks and ticks are before this.}
Channels are input sources to Rizzo programs, and can be considered to be  associated with a clock. Each tick of the channel's clock represents an input event on the channel.
\todo{There is only one clock}

\todo{associate this with a diagram of some kind that shows the flow of data from channels -to- signals -to- output signals.}


\subsection{The delayOnce type}
The delayOnce type is used to represent values that will be available at the second time step, if the first time step is the creation of the type.

\subsection{The Later type}
The Later type is used to represent values that will be available at a later time step. In contrast to delayOnce, the Later type does not guarantee that the value will be available at the next time step, but only at some later time step. For example, using a filter on a signal will produce a signal that does not guarantee a value at the next time step, since the filter may not pass any values through.

\todo{Insert an example that shows how a map will also not guarantee a value if the filter has not met its condition yet.}

\subsection{Signals}
Signals are the core concept in Rizzo, and represent time-varying values. Signals can be constructed from channels, or from other signals using signal combinators.
Signals are implemented as an infinite sequence, with the head being the current value of the signal, and the tail being a new later signal of the same type.

For a reader unfamiliar with FRP, the signals can be considered a pipes where values flow through the network and ends up at output signals.


% \clearpage

% \subsection{A simpler processor model}\label{processor-model}
