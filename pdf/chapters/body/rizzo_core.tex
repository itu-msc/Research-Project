\section{Rizzo Core private methods}
%The core, whatever "glues" the concepts together, making it a language
To give executable meaning to these constructions (\todo{signal, oe, oa}), Rizzo defines operational semantics. The operational semantics of Rizzo are split into two parts. The first part is the evaluation semantics which describe how terms are computed. The second part, the reactive semantics, describe how signals and later values \textit{react} to input over time. Since our implementation of Rizzo is an embedded language, the evaluation semantics are provided by OCaml. Therefore, this section will primarily focus on the reactive semantics and the other necessary aspects that are needed to make Rizzo \textit{reactive}.

% You cannot have a headless signal 
%the type and how to construct these
\subsection{The heap}
%Conceptually, how the heap should work
In Rizzo signals are stored in a specalized heap. This heap is divided in two: Namely, the `now' heap $\eta_n$ and the `earlier' heap $\eta_e$. We say that signals in the `now' are considered \textit{up-to-date} and signals in the `earlier' heap are old, that is they belong to the past and must be \textit{advanced} before they can be used. Conceptually, a heap is a sequence of mappings $id \mapsto v\langle U \rangle w$, which map an identifier to the data of a signal. This data contains the head $v$ and tail $w$ of a signal alongside a flag that indicates whether the signal has been updated in the current time step. This flag plays an important for the reactive semantics described in section \ref{rizzo_semantics}. The heap provides a way to create fresh signals identifiers by using the function $\text{alloc} : A \rightarrow \text{later } A$.
%Does this also include channels?

In our library, the `now' and `earlier' heaps are implemented as a single doubly-linked list. To achieve the two-part heap, we keep a to the last element of the `now' heap, called the `cursor', which marks the boundary. There choice of data structure is based on the requirements of the reactive semantics (section \ref{rizzo_semantics}): Firstly, whenever a new signal is allocated it should be put in the `now' part of the heap and hence we need fast insertion. Secondly, we need to be able to move data between the `now' and `earlier' heap efficiently, because it happens for every tick in time. Thirdly, we must be able to efficiently remove siganls once they are no longer needed. The linked list offers easy instertion and delation at arbitrary positions and the `cursor' reference makes it cheap to move data from the `earlier' heap to the `now' heap by simpling changing a reference.

However, since we are creating an embedded language, it is necessary to work within the OCaml memory model and that means co-existing with the OCaml garbage collector. If our heap were to directly hold reference to signals and their data, then it would stop the garbage collector from ever erasing any unused signal. Therefore, we must utilise weak references, which are pointers to values that the garbage collector is allowed to erase whenever it is no longer used elsewhere \todo{cite ocaml weak(?)}. This greatly simplifies the memory management of our library, by requiring only that we remove garbage collected references from the signal heap. However, it also means that we have no control on when unused signals are erased from memory and as such they may persist in the signal heap for longer than expected. This is especially problematic for any signals with side effects. 
\todo{Consider the Rizzo program in listing \ref{heap_side_effect}.} The program defines a signal of strings, the tail of which has a side effect, namely printing $[\text{side-effect}]$, and then the program immediately ignores this signal. Note, the infix operator $(@\text{:})$ creates a new signal which is allocated on the heap exactly like $(\text{::})$ for lists. It would be reasonable to expect the program to do nothing but infinitely hang in the event loop. However, when the program is run and as the first value is produced on the $console\_input$ channel, the program prints $[\text{side-effect}]$. This happens because the garbage collector has yet to run so the ignored signal still sits in the signal heap and is thus updated every time console produces a value.
\begin{lstlisting}[caption={A Rizzo programs that produces unexpected output of a signal with side effects.}, label={heap_side_effect}]
let console = mkSig_of_channel (console_input ()) in
let id_with_side_effect = 
    fun x -> print_endline "[side-effect]"; x in
ignore ("initial" @: mapD id_with_side_effect console);
start_event_loop ()
\end{lstlisting}
\todo{Is it necessary to say more about signal allocation?}

%Concrete implementation, why a linked list? Why weak reference etc. Also the "alloc" to create signals.

\subsection{Rizzo semantics}\label{rizzo_semantics}
%Stuff like step, advance, 
In Rizzo time `ticks' whenever input is produced on any channel, we say the program enters a new \textit{time step}. This begins a process, described by the \textit{step semantics}, which brings all signals into this new time step by either updating or moving them. At a high level, this process first moves everything to the `earlier' heap. Then it goes through the entire heap, checking for each signals whether it has been affected by the new `tick' and and if so, then we say the signal has `ticked'. If a signal has ticked as a result of new input then it must be updated. To update a signal, its tail is advanced, producing a new head and tail as described by the \textit{advance semantics}. If a signal has not ticked, then it is simply moved into the new time step unchanged.

The implementation follows naturally from the above description. To update the heap, we first set the heap cursor to be the first element, then we loop over the heap calling the function $ticked : \text{channel } B \rightarrow \text{later } A \rightarrow bool$ to determine if a particular signal has ticked given the channel that produced the time step. Any signal that has not ticked is is moved by just moving the cursor forward (\todo{Also, we set the flag to not updated}). Whereas any signal that has ticked is advanced by calling $advance : \text{channel } B \rightarrow \text{later } A \rightarrow B \rightarrow A$ on the channel, the produced value and the signal which results in a signal, which may or may not be a newly allocated (\todo{for example, tail doesn't make a new one}). Then the data of the original signal is updated by mutating the underlying data record, which can be seen in listing \ref{rizzo_step}. (\todo{Explain how we model signals.})

\begin{lstlisting}[caption={Code for updating the heap}, label={rizzo_step}]
let step_cursor : 'a channel -> 'a -> unit = fun k v ->
  match node_get_data heap.cursor with
  | None -> delete heap.cursor; incr_cursor ()
  | Some cursor_data -> 
    let {tail = v2; _} : 'a signal_data = cursor_data in
    if not (ticked k v2) then 
      let () = cursor_data.updated <- false in
      incr_cursor ()
    else
      let v' = signal_get_data (advance k v2 v) in
      update heap.cursor v'.head v'.tail;
      cursor_data.updated <- true;
      incr_cursor ()
\end{lstlisting}

%Note, this creates the problem of suddenly, you have two signals with the same tail. ~~ Therefore, we must explicitly call the garbage collector. Reference counting would save us. ~~ I suggest moving this to a chapter of its own?
\todo{Problem 1: this creates signals with duplicate tails. This is bad for side effects which not a problem since the language makes no guarantees for side effects. Exactly why breaks the \ref{heap_side_effect} However, it also means our implementation of $console\_output$ breaks \dots therefore we must call Gc}

%Mention that we are using GADTs and therefore we must in our implementation use "polymorphic recursion". In OCaml we must explicitly state the universally quantified type varaible:
% https://stackoverflow.com/a/69144537
% https://ocaml.org/manual/5.4/polymorphism.html#s:polymorphic-recursion
\todo{Problem 2: polymorphic recursion as a result of GADTs. }

\subsection{Input, output, and event loop} \label{rizzo_io}
\todo{How are channels handled $\Rightarrow$ we spawn separate threads for console, clock, and port. REMEMBER TO MENTION SYNCHRONISATION access to the heap is proteceted by a mutex to avoid entering illegal states where the heap cursor is in multiple places\dots (should we mention happens-before?)}

\todo{Output, when users registers a signal to output then we create a new signal that has the side effect of printing. To avoid GC eating our output signals, we have to store these in a global variable. AND because we are sort of abusing the heap ourselves, we have to explicitly call GC in heap (to avoid duplicating prints each tick). Could be fixed be 1 handling these signals different, maybe manually checking if they ticked at the end of a step or 2 updating signals in place to avoid the duplicating tails}

\todo{The event loop. When a user is finished defining their signals, they \textit{start} the event loop. This blocks the main thread, so the program doesn't preemptively terminate. Also means that after this point all work is done entirely on input threads, which may cause `clock signal' (etc.) to go out of sync. Additionally, the threads (for input) are all started eagerly, meaning as soon they are invoked. So, while running the `setup', all the code before `start\_event\_loop', it may be that input is produced on channels before all signals have been declared. Meaning, for this brief period of execution it is possible that input is dropped, i.e. not given to some signals because they just do not exist in the heap yet!}

