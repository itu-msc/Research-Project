\section{Rizzo Core private methods}
%The core, whatever "glues" the concepts together, making it a language
To give executable meaning to these constructions (\todo{signal, oe, oa}), Rizzo defines operational semantics. The operational semantics of Rizzo are split into two parts. The first part is the evaluation semantics which describe how terms are computed. The second part, the reactive semantics, describe how signals and later values \textit{react} to input over time. Since our implementation of Rizzo is an embedded language, the evaluation semantics are provided by OCaml. Therefore, this section will primarily focus on the reactive semantics and the other aspects necessary to make Rizzo \textit{reactive}.

% You cannot have a headless signal 
%the type and how to construct these
\subsection{The heap}
%Conceptually, how the heap should work
In Rizzo signals are stored in a specialized heap. This heap is divided in two: Namely, the `now' heap $\eta_n$ and the `earlier' heap $\eta_e$. We say that signals in the `now' are considered \textit{up-to-date} and signals in the `earlier' heap are old, that is they belong to the past and must be \textit{advanced} before they can be used. Conceptually, a heap is a sequence of mappings $id \mapsto v\langle U \rangle w$, which map an identifier to the data of a signal. This data contains the head $v$ and tail $w$ of a signal alongside a flag that indicates whether the signal has been updated in the current time step. This flag plays an important for the reactive semantics described in section \ref{section:rizzo_semantics}. The heap provides a way to create fresh signals identifiers by using the function $\text{alloc} : A \rightarrow \text{later } A \rightarrow \text{Signal }A$ .
%Does this also include channels?

In our library, the `now' and `earlier' heaps are implemented as a single doubly-linked list. To achieve the two-part heap, we keep a pointer to the last element of the `now' heap, called the `cursor', which marks the boundary. The choice of data structure is based on the requirements of the reactive semantics (section \ref{section:rizzo_semantics}): Firstly, whenever a new signal is allocated it should be put in the `now' part of the heap and hence we need fast insertion. Secondly, we need to be able to move data between the `now' and `earlier' heap efficiently, because it happens for every tick in time. Thirdly, we must be able to efficiently remove signals once they are no longer needed. The linked list offers fast insertion and deletion at arbitrary positions and the `cursor' reference makes it cheap to move data from the `earlier' heap to the `now' heap by simply changing a reference.

However, since we are creating an embedded language, it is necessary to work within the OCaml memory model and that means co-existing with the OCaml garbage collector. If our heap were to directly hold reference to signals and their data, then it would prevent the garbage collector from ever erasing any unused signal. Therefore, we must utilise weak references, which are pointers to values that the garbage collector is allowed to erase whenever they are no longer in use elsewhere \todo{cite ocaml weak(?)}. This greatly simplifies the memory management of our library, by requiring only that we remove garbage collected references from the signal heap. However, it also means that we have no control on when unused signals are erased from memory and as such they may persist in the signal heap for longer than expected. This is especially problematic for any signals with side effects. 
\todo{Consider the Rizzo program in listing \ref{listing:heap_side_effect}.} The program defines a signal of strings, the tail of which has a side effect, namely printing $[\text{side-effect}]$, and the program then immediately ignores this signal. Note, the infix operator $(@\text{:})$ creates a new signal which is allocated on the heap exactly like $(\text{::})$ for lists. It would be reasonable to expect the program to do nothing but infinitely hang in the event loop. However, when the program is run and as the first value is produced on the $console\_input$ channel, the program prints $[\text{side-effect}]$. This happens because the garbage collector has yet to run, meaning the ignored signal still sits in the signal heap and is thus updated every time console produces a value.
\begin{lstlisting}[caption={A Rizzo programs that produces unexpected output of a signal with side effects.}, label={listing:heap_side_effect}]
let console = mkSig_of_channel (console_input ()) in
let id_with_side_effect = 
    fun x -> print_endline "[side-effect]"; x in
ignore ("initial" @: mapL id_with_side_effect console);
start_event_loop ()
\end{lstlisting}
\todo{Is it necessary to say more about signal allocation?}

%Concrete implementation, why a linked list? Why weak reference etc. Also the "alloc" to create signals.

\subsection{Rizzo semantics}\label{section:rizzo_semantics}
%Stuff like step, advance, 
In Rizzo time `ticks' whenever input is produced on any channel, we say the program enters a new \textit{time step}. This begins a process, described by the \textit{step semantics}, which brings all signals into this new time step by either updating or moving them. At a high level, this process first moves everything to the `earlier' heap. Then it goes through the entire heap, checking for each signals whether it has been affected by the new `tick' and and if so, then we say the signal has `ticked'. If a signal has ticked as a result of new input then it must be updated. To update a signal, its tail is advanced, producing a new head and tail as described by the \textit{advance semantics}. If a signal has not ticked, then it is simply moved into the new time step unchanged.

The implementation follows naturally from the above description. To update the heap, we first set the heap cursor to be the first element, then we loop over the heap calling the function $ticked : \text{channel } B \rightarrow \text{later } A \rightarrow bool$ to determine if a particular signal has ticked given the channel that produced the time step. Any signal that has not ticked is is moved by setting its updated-flag to false and moving the cursor forward. Whereas any signal that has ticked is advanced by calling $advance : \text{channel } B \rightarrow \text{later } A \rightarrow B \rightarrow A$ on the channel, the tail, and the produced value which results in a signal, that may be newly allocated. The data of the original signal is updated by mutating the underlying data record. (\todo{Make sure we explained how signals are modelled before this.})

%Note, this creates the problem of suddenly, you have two signals with the same tail. ~~ Therefore, we must explicitly call the garbage collector. Reference counting would save us. ~~ I suggest moving this to a chapter of its own?
While this approach is simple, it also means that after a signal is updated, there will exist (at least) two identical signals in the heap.
%Problem 1: this creates signals with duplicate tails. This is bad for side effects which not a problem since the language makes no guarantees for side effects. Exactly why breaks the \ref{listing:heap_side_effect} However, it also means our implementation of $console\_output$ breaks \dots therefore we must call Gc
Combined with the problem of garbage collection (see listing  \ref{listing:heap_side_effect}), the heap can grow rapidly (sometimes doubling each tick) if left unattended. This is disastrous for both performance and any side effects present in delayed computations. An ever-growing heap that brings the program to a crawl is unacceptable. Moreover, despite the language providing no guarantees about side effects\cite{rizzo_modal_2025}, we cannot ignore them entirely, since they are used in the implementation of outputs (section \ref{section:rizzo_io}). Fortunately, a single explicit call to trigger garbage-collection cycle largely fixes both these issues. 

\todo{DISCUSSION $\Rightarrow$ Reference counting also would've fixed these issues.}

%Mention that we are using GADTs and therefore we must in our implementation use "polymorphic recursion". In OCaml we must explicitly state the universally quantified type variable:
% https://stackoverflow.com/a/69144537
% https://ocaml.org/manual/5.4/polymorphism.html#s:polymorphic-recursion
\todo{Problem 2: polymorphic recursion as a result of GADTs. }

\subsection{Input, output, and the event loop} \label{section:rizzo_io}

The event loop in Rizzo follows naturally from the reactive semantics \ref{section:rizzo_semantics}, whenever an input is produced on any channel \textit{something} must update the heap by invoking $step : \text{Channel } A \rightarrow A \rightarrow ()$ with the corresponding channel and the produced value. In our implementation, the responsible \textit{something} are separate threads. That is each of the primitive channels \texttt{console\_input, clock, port\_input}, create their own thread which is then responsible for handling input from the console, a timer, or a unix socket respectively and calling $step$. Since processing events from the environment has been delegated to separate worker threads, the crucial function \texttt{start\_even\_loop} does nothing more than block the main thread to avoid preemptive termination.

%How are channels handled $\Rightarrow$ we spawn separate threads for console, clock, and port. REMEMBER TO MENTION SYNCHRONISATION access to the heap is proteceted by a mutex to avoid entering illegal states where the heap cursor is in multiple places\dots (should we mention happens-before?)
However, because users can request multiple channels in a single Rizzo program, the runtime is in the general case multi-threaded. This means we must ensure that heap updates are synchronised (related by \textit{happens-before}) to avoid race conditions and leaving the heap partially updated. Therefore, the $step$ function is protected by a single mutex. 

It is sufficient with a single mutex for the entire heap, as the semantics of Rizzo are single-threaded. In other words, the only time that data on the heap is read or changed, is while updating the heap, specifically when delayed computations are advanced. This corresponds exactly to the $inner$ call in listing \ref{listing:rizzo_step}.
%If a user were to create their own channel with `getInput' and then attempt to push values onto this channel from a signal ... the application deadlocks. This behaviour is fine, channels are meant for external input sources. Signals are internal!
\begin{lstlisting}[caption={Implementation of step semantics. Step takes a channel $k$, the produced value $v$, and updates the heap.}, label={listing:rizzo_step}]
let step k v : unit = 
  Mutex.lock mutex;
  let rec inner : unit -> unit = fun () ->
    if Option.is_none heap.cursor.next then ()
    else let () = step_cursor k v in inner () 
  in 
  reset_cursor ();
  inner ();
  Gc.full_major ();
  Mutex.unlock mutex;
\end{lstlisting}
%The event loop. When a user is finished defining their signals, they \textit{start} the event loop. This blocks the main thread, so the program doesn't preemptively terminate. Also means that after this point all work is done entirely on input threads, which may cause `clock signal' (etc.) to go out of sync. Additionally, the threads (for input) are all started eagerly, meaning as soon they are invoked. So, while running the `setup', all the code before `start\_event\_loop', it may be that input is produced on channels before all signals have been declared. Meaning, for this brief period of execution it is possible that input is dropped, i.e. not given to some signals because they just do not exist in the heap yet!
A consequence of this architecture is once a user commits to the event loop, all subsequent work is performed on the threads responsible for handling system input. This means any code for handling input (e.g. reading from a network socket) is delayed by the time it takes to update the heap, which may lead to timers going out of sync or systems that seem unresponsive.
Additionally, the threads of the primitive channels are all started eagerly. As a result, they may produce values while the program is still constructing signals, potentially causing any uninitialized signal to miss early input.

Outputs 
\todo{Output, when users registers a signal to output then we create a new signal that has the side effect of printing. To avoid GC eating our output signals, we have to store these in a global variable. AND because we are sort of abusing the heap ourselves, we have to explicitly call GC in heap (to avoid duplicating prints each tick). Could be fixed be 1 handling these signals different, maybe manually checking if they ticked at the end of a step or 2 updating signals in place to avoid the duplicating tails}



