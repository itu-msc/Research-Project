Reactive programs are long-lived programs that continously receive input from and produce output to its environment. Functional Reactive Programming\cite{ElliottHudak97:Fran} (FRP) is a high level declarative programming paradigm for building reactive programs. Examples of such programs include servers, games and GUIs. 

At the core of FRP abstractions is the \textit{signal} (also known as \textit{behaviours}\cite{ElliottHudak97:Fran}) which models the interaction with the environment. Signals are streams of time-dependent values that may arrive later. Signals can be manipulated, combined, and consumed using the techniques of regular functional programming. However, incorrectly using signals may lead to space leaks in long-running programs\cite{gebser_asynchronous_2023}. \todo{How?!} \todo{Should we go into the details of these problems? And how \textit{causality, productivity, no-space leaks}?}

\section{Modal Types}
To help programmers avoid introducing space leaks (\todo{and other problems}) previous work introduces \textit{modal types}\cite{gebser_asynchronous_2023}. These are introduced as primitive types in order to guarantee that well-typed program are free of space leaks (\todo{and casual + productive}). There are two main modal types: The later modality $\bigcirc A$ which describes the promise of a value of type $A$ becoming available later and the stable modality $\square A$ which describes a time-independent value of type $A$ that is available at any time. Using these modal types we can safely define the signal type as: 
\[\textbf{type} \text{ Sig } a = a :: \bigcirc (\text{Sig } a)\] 
With this definiton of signals it is possible to define a map function $map : \square (a \rightarrow b) \rightarrow \text{Sig }a \rightarrow \text{Sig }b$. Observe, the type $\square (a \rightarrow b)$ is crucial here, as it disallows the function from capturing references to old values which would otherwise cause space leaks.
%Jeg prøver at skabe et eksempel for vores claim "However, having several modal types comes at a cost of making the type system more restrictive and complex. Which makes it less practical for real-world applications."
This leads directly the main downside of modal types, namely the added complexity and extra restrictions imposed. Consider $mult2 : \text{Sig }a \rightarrow \text{Sig }a$, a function that multiplies values of a given signal by two: \[mult2 \; xs = map \; (box \;(\lambda x. x * 2)) \; xs\]
Observe, that the type system requires additional work from the programmar and computation in the form of a $box$ operation in order to fit the stable modality.

\section{Rizzo}
Rizzo(\todo{cite rizzo}) is a FRP language that simplifies the type system while still preserving the safety guarantees. It achieves this by changing the semantics of signals. With the new semantics signals are mutable references: $\textbf{type} \text{ Sig } a = \text{ref } (a \times \bigcirc (\text{Sig } a))$. Meaning that the type of a signal is a mutable reference to a pair of $(u,v)$ with current value $u$ (the head) and tail $v$, a delayed computation used to update the reference in the next time step. Importantly, users of Rizzo do not update this reference themselves, instead the reference is updated by evaluating the tail $v$ and the how-to is precisely defined in the \textit{reactive semantics} \ref{background}.

These mutable references allow Rizzo to forego the need for the $\square$ (stable) modality. This means it is possible to more naturally define $map : (a \rightarrow b) \rightarrow \text{Sig }a \rightarrow \text{Sig }b$. Additionally, it also becomes impossible for Rizzo programs to hold references to the same signal from different time steps, allowing redefining $mult2 \; xs = map \; (\lambda x. x + head \; xs) \; xs$.

%Er der mere at sige om Rizzo? Hvorfor er Rizzo interessant?

\section{Contributions}
This project/paper demonstrates the possibility of implementing Rizzo as an embedded language by making library implementation \todo{in Ocaml?}.


% Related literature
% - Andre muligheder, andre løsninger
% - Kunne være flere af hans papers, Async rattus?
% - Tidligere års compiler implementationer?
%