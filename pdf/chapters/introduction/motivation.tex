Reactive programs are long-lived programs that continously interact with their environments, receiving input and producing output. Examples of reactives programs include servers, games and GUIs\todo{cite?}. 

Functional Reactive Programming\cite{ElliottHudak97:Fran} (FRP) is a high level programming paradigm for building reactive programs. FRP lets programmers use the familiar techniques of funcitonal programming to implement and reason about time-flow and events in order to build reactive programs. The result is paradigm in which reactive programs are built declaratively. 

At the core of FRP is the abstraction of a \textit{signal} (also known as \textit{behaviours}\cite{ElliottHudak97:Fran}), which models the interaction with the environment. Signals are streams of time-dependent values, that may arrive later, and can be manipulated, combined, and consumed using regular functional programming techniques. However, the incorrect use of signals may lead to space leaks where old values of signals are kept in memory for too long\cite{bahr_asynchronous_2023}. \todo{An example?} \todo{Should we go into the details of \textit{causality, productivity}?}

\section{Modal Types}
To help programmers avoid introducing space leaks (\todo{and other problems}) previous work introduces \textit{modal types}\cite{gebser_asynchronous_2023}. These are introduced as primitive types in order to guarantee that well-typed program are free of space leaks (\todo{and casual + productive}). There are two main modal types: The later modality $\bigcirc A$ which describes the promise of a value of type $A$ becoming available later and the stable modality $\square A$ which describes a time-independent value of type $A$ that is available at any time. Using these modal types we can safely define the signal type as: 
\[\textbf{type} \text{ Sig } a = a :: \bigcirc (\text{Sig } a)\] 
With this definiton of signals it is possible to define a map function $map : \square (a \rightarrow b) \rightarrow \text{Sig }a \rightarrow \text{Sig }b$. Observe, the type $\square (a \rightarrow b)$ is crucial here, as it disallows the function from capturing references to old values which would otherwise cause space leaks.

%Jeg prøver at skabe et eksempel for vores claim "However, having several modal types comes at a cost of making the type system more restrictive and complex. Which makes it less practical for real-world applications."
However, this elegant solution comes at the cost of added complexity to the type checker and for users. Whenever a function like $map$ is used the type checker must ensure, through typing rules, that the provided function only uses other stable variables\cite{bahr_asynchronous_2023}. Additionally, programmers must perform a dance with the compiler to make types fit, consider as an example $mult2 : \text{Sig }a \rightarrow \text{Sig }a$, a function takes a signal to produce a new signal where the original values have been multiplied by two: \[mult2 \; xs = map \; (box \;(\lambda x. x * 2)) \; xs\]
Observe in particular the use of $box$ that is required fit the stable modality of $map$.

\section{Rizzo}
Rizzo(\todo{cite rizzo}) is a FRP language that simplifies the type system while still preserving the same safety guarantees. It achieves this by changing the semantics of signals. With the new semantics signals are mutable references: $\textbf{type} \text{ Sig } a = \text{ref } (a \times \bigcirc (\text{Sig } a))$. Meaning that the type of a signal is a mutable reference to a pair of $(u,v)$ with current value $u$ (the head) and tail $v$, a delayed computation used to update the reference in the next time step. Importantly, users of Rizzo do not update this reference themselves, instead the reference is updated by evaluating the tail $v$. The process of updating signals is defined by the \textit{reactive semantics}\space\ref{background}. 

The mutable references in the semantics of signals is what allows Rizzo to forego the $\square$ (stable) modality. Since signals are updated in place, it is impossible for Rizzo programs to reference the same signal from different time steps. Without the stable modality we can redefine $map : (a \rightarrow b) \rightarrow \text{Sig }a \rightarrow \text{Sig }b$ and use it to also redefine the $mult2 \; xs = map \; (\lambda x. x + head \; xs) \; xs$ function. Notice that in Rizzo, it is allowed to reference $xs$ from inside the function argument of $map$ even though it would not type check with the stable modality of our previous $map$ definition. 

%Er der mere at sige om Rizzo? Hvorfor er Rizzo interessant?

\section{Contributions}
In this paper we implement a library implemention of Rizzo in Ocaml in order to demonstrate the possibility of implementing Rizzo as an embedded language. We successfully implement a library (see \ref{background} for examples) and highlighting some of the difficulties and limitations that come from embedding the language. In particular when the semantics of Rizzo clash with side effects, the memory model, etc. that can be found in Ocaml.

% Related literature
% - Andre muligheder, andre løsninger
% - Kunne være flere af hans papers, Async rattus?
% - Tidligere års compiler implementationer?
%