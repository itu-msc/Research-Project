\section{Using Rizzo} \label{using_rizzo}
%user space, examples of how to use it?
%Input channels : Clock signals, console signal, 
%Output "channels":

This section will give an overview of how Rizzo can be used to implement functional reactive programs. We will go through how to create input signals, use signal combinators to manipulate the signals, and how to output the signals. We then combine the three, and show an example program that uses Rizzo to implement a simple interactive application.

\subsection{Inputs}
Input sources in Rizzo are called channels. There can theoretically be implemented an input channel for any kind of input source, but currently Rizzo only has a console, clock and port input implementation.

To use one of the input channels, the user requests to get one of the channels from Rizzo, and then uses the channel to create signals. For example, bellow we show how a console input channel can be used to create a signal that represents the input from the console.

\begin{lstlisting}
open Rizzo
let console_channel = Channel.console_input () in
let console_signal = Signal.from_channel console_channel
\end{lstlisting}

\subsection{Signal combinators}
Signals are the bread and butter of Rizzo, and Rizzo provides a number of signal combinators that can be used to manipulate signals. Some of the most notable signal combinators are \texttt{map}, \texttt{filter} and \texttt{sample}. Signal combinators come in two variants, the normal variant that works on regular signals, and the later variant that works on later signals. The later variant is denoted by appending an L to the name of the combinator.

A brief overview of the signal combinators is given below:
\begin{itemize}
  \item \texttt{map}: Takes a function and a signal as input, and produces a new signal where the function has been applied to each value of the input signal.
  \item \texttt{filter}: Takes a predicate function and a signal as input, and produces a new signal that only contains values that satisfy the predicate.
  \item \texttt{sample}: Takes two signals as input, and produces a new signal that contains the tuple values from both signals whenever the first signal produces a value.
\end{itemize}

\subsection{Outputs}
Rizzo provides output functions that can be used to output signals to various output sources. Currently Rizzo has output functions for console and network port outputs. Like the signal combinators there can be two variants, one for regular signals and one for later signals. Unlike the signal combinators, the output functions do not produce a new signal, but instead have the side effect of outputting the signal values to the output source.

\subsection{Example program}

To give some insight into how Rizzo can be used, we will in this section present a small example program that uses Rizzo to implement a simple interactive application. The application will read input from the console and a network port, and will output values to the console and the network port based on the input it receives.

First we need to open the Rizzo modules that we will use in our program. In this case we will use the \texttt{Types}, \texttt{Signal} and \texttt{Channel} modules.

\begin{lstlisting}
open Rizzo.Types
open Rizzo.Signal
open Rizzo.Channel
\end{lstlisting}

Now that we have access to the Rizzo modules, we can start implementing our application. The application will need to read input from the console and a network port. We do that by creating input channels for the console and the network port.

\begin{lstlisting}
let console_channel = console_input () in
let port_channel = port_input 9000 in
\end{lstlisting}

Using the channels, we can create signals that represent the input from the console and the network port.

\begin{lstlisting}
let console_in = mkSig_of_channel console_channel in
let port_in = mkSig_of_channel port_channel in
\end{lstlisting}

If we simply wanted to output the input signals directly to the console, we would only need to use the \texttt{console\_outputL} function to output the signals values. \texttt{console\_outputL} takes a later signal as input, where the L indicates that the signal is of a later type.

\begin{lstlisting}
console_outputL (console_in);
console_outputL (port_in);
\end{lstlisting}

However, to demonstrate the use of the map signal combinator in Rizzo, We will map the input to a new string with a prefix, before outputting them to the console. The \texttt{mapL} combinator takes a function and a later signal as input, and produces a new later signal where the function has been applied to each value of the input signal.

\begin{lstlisting}
console_outputL (mapL (fun s -> "From console: " ^ s) console_in);
console_outputL (mapL (fun s -> "From port: " ^ s) port_in);
\end{lstlisting}

Given we have not made a client that writes to the port, the port output will not produce any output, so lets fix that by taking the input from the console and writing it to the port as well. We can use the \texttt{port\_outputL} function from the \texttt{Channel} module to output to the port.

\begin{lstlisting}
port_outputL Unix.inet_addr_loopback 9000 console_in;
\end{lstlisting}

To block the main thread so the program does not exit, we call \lstinline{start_event_loop ();} at the end of the program.

An example interaction with the program so far could look like this:

\begin{verbatim}
Hello Rizzo
From console: Hello Rizzo
From port: Hello Rizzo
Hello again
From console: Hello again
From port: Hello again
\end{verbatim}

This was quite a simple program, but to show some more of Rizzo's capabilities, we can extend the program a bit further. Good examples of signal combinators are \texttt{filter} and \texttt{sample}.

The \texttt{filter} function takes a predicate function and a signal as input, and produces a new signal that only contains values that satisfy the predicate. 

We could for example filter the console input signal to only contain values where the string equals `time'.

\begin{lstlisting}
let time_filter = filterL (fun s -> s = "time") console_in in
\end{lstlisting}

The \texttt{sample} function on the other hand, takes two signals, and produces a new signal that contains the tuple values from both signals whenever the first signal produces a value.

We could for example sample a clock signal that ticks every second with the filtered console signal.

To make a clock signal that ticks every second, we can use the \texttt{clock\_signal} function from the \texttt{Channel} module.

\begin{lstlisting}
let every_second, every_second_stop = clock_signal 1.0 in
let start_time = head every_second in
let sampled_console = sampleL time_filter every_second in
\end{lstlisting}

The \texttt{every\_second\_stop} value is a function that can be called to stop the clock signal when it is no longer needed. This mostly applies to long running programs that need to clean up resources when they exit.

We can then output the sampled console signal to the console, prepending a string to the output values.

\begin{lstlisting}
let formatted =
  (mapL (fun (_, f) -> string_of_float (f -. start_time))
    sampled_console) in
console_outputL formatted;
\end{lstlisting}

This will now output the time in seconds since the program started whenever the user inputs `time' in the console.

The full example program can be seen in Appendix~\ref{appendix:extended_example_program}.

\section{Implementing Rizzo} \label{section:implementing_rizzo}

Rizzo is implemented in \texttt{OCaml}, because it has weak references, generalized algebraic data types (GADTs) and a strong type system. We could potentially have better performance if we chose a language with reference counting, but OCaml is a good trade-off between performance and expressiveness.
We have implemented Rizzo as a library, where we have drawn a line between the core implementation and the user space. The intention with making this distinction is \texttt{if users follow our APIs}, then they will get the safety guarantees that Rizzo was designed for. If they don't, they could potentially break the guarantees Rizzo provides, by for example introducing side effects. As an OCaml library we cant guarantee that users will not introduce side effects, so we have to trust that they will follow the APIs.

Most of the implementation of Rizzo is contained in the \texttt{internals} module, which contains the core implementation of Rizzo. The \texttt{types} module contains the type definitions and type constructors used in Rizzo, and the \texttt{signal} and \texttt{channel} modules contain the signal combinators and channel implementations respectively. We have not hidden this implementation behind an abstract interface, since we want users to be able to extend Rizzo with new functionality if they want to. So input channels can for example be extended by users to support new input sources.

\todo{add stuff about space/time leaks}

\subsection{Channels}
\todo{Make sure that we have explained what clocks and ticks are before this.}
Channels are input sources to Rizzo programs, they are controlled by the Rizzo runtime, and provided to the user through the Rizzo Channel module.
Channels produce input events at discrete time steps, and 

, and can be considered to be associated with a clock. Each tick of the channel's clock represents an input event on the channel.
\todo{There is only one clock}

\todo{associate this with a diagram of some kind that shows the flow of data from channels -to- signals -to- output signals.}


\subsection{The delayOnce type}
\todo{I need a bit of help here, what exactly is it used for exept for helping us with not evaluating values and functions too early? ie given we dont have call-by-name in ocaml, this is just a thunk wrapper right?}
The delayOnce type is used to represent values that will be available at the next time step. This is useful when we have a function that we want to pass, but we don't want to evaluate the function until the next time step. 

delayOnce is implemented as a wrapper around a thunk, which is a function that takes no arguments and returns a value. The thunk is only evaluated when the value is needed, which is at the next time step.

\subsection{The Later type}
The Later type is used to represent values that will be available at a later time step. In contrast to delayOnce, the Later type does not guarantee that the value will be available at the next time step, but only at some later time step. For example, using a filter on a signal will produce a signal that does not guarantee a value at the next time step, since the filter may not pass any values through.

We can for example make a later signal from a filter that never passes any values through, resulting in a later signal that never produces any values.

\begin{lstlisting}
let never_signal = filterL (fun _ -> false) some_input_signal in
\end{lstlisting}

The internal type signature of Later is a GADT

\begin{lstlisting}
type _ later =
  | Never
  | App : ('a -> 'b) delayOnce * 'a later -> 'b later   (* this is the O>*)
  | Sync : 'a later * 'b later -> ('a, 'b) sync later
  | Wait : 'a channel -> 'a later
  | Trig : 'a option signal -> 'a later
  | Tail : 'a signal -> 'a signal later
...
\end{lstlisting}

\subsection{Signals}
Signals are the core concept in Rizzo, and represent time-varying values. Signals can be constructed from channels, or from other signals using signal combinators.
Signals are implemented as an infinite sequence, with the head being the current value of the signal, and the tail being a new later signal of the same type.

For a reader unfamiliar with FRP, the signals can be considered to be pipes where values flow through the network and ends up at output signals.


% \clearpage

% \subsection{A simpler processor model}\label{processor-model}
