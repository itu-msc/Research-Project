\section{Using Rizzo}\label{using_rizzo}
%user space, examples of how to use it?
%Input channels : Clock signals, console signal, 
%Output "channels":

This section will give an overview of how Rizzo can be used to implement functional reactive programs. We will go through how to create input signals, use signal combinators to manipulate the signals, and how to output the signals. We then combine the three, and show an example program that uses Rizzo to implement a simple interactive application.
We then finish the section with a list of the most notable functions and types provided by Rizzo.

\subsection{Inputs}
Input sources in Rizzo are called channels. There can theoretically be implemented an input channel for any kind of input source, but currently Rizzo only has a console, clock and port input implementation.

To use one of the input channels, the user requests to get one of the channels from Rizzo, and then uses the channel to create signals. For example, bellow we show how a console input channel can be used to create a signal that represents the input from the console.

\begin{lstlisting}
open Rizzo
let console_channel = Channel.console_input () in
let console_signal = Signal.mkSig_of_channel console_channel
\end{lstlisting}

\subsection{Signal combinators}
Signals are the bread and butter of Rizzo, and Rizzo provides a number of signal combinators that can be used to manipulate signals. Some of the most notable signal combinators are \texttt{map}, \texttt{filter} and \texttt{sample}. Signal combinators come in two variants, the normal variant that works on regular signals, and the later variant that works on later signals. The later variant is denoted by appending an L to the name of the combinator.

A brief overview of the signal combinators is given below:
\begin{itemize}
  \item \texttt{map}: Takes a function and a signal as input, and produces a new signal where the function has been applied to each value of the input signal.
  \item \texttt{filter}: Takes a predicate function and a signal as input, and produces a new signal that only contains values that satisfy the predicate.
  \item \texttt{sample}: Takes two signals as input, and produces a new signal that contains the tuple values from both signals whenever the first signal produces a value.
\end{itemize}

\subsection{Outputs}
Rizzo provides output functions that can be used to output signals to various output sources. Currently Rizzo has output functions for console and network port outputs. Like the signal combinators there can be two variants, one for regular signals and one for later signals. Unlike the signal combinators, the output functions do not produce a new signal, but instead have the side effect of outputting the signal values to the output source.

\subsection{Example program}\label{section:rizzo_example}

To give some insight into how Rizzo can be used, we will in this section present a small example program that uses Rizzo to implement a simple interactive application. The application will read input from the console and a network port, and will output values to the console and the network port based on the input it receives.

First we need to open the Rizzo modules that we will use in our program. In this case we will use the \texttt{Types}, \texttt{Signal} and \texttt{Channel} modules.

\begin{lstlisting}
open Rizzo.Types
open Rizzo.Signal
open Rizzo.Channel
\end{lstlisting}

Now that we have access to the Rizzo modules, we can start implementing our application. The application will need to read input from the console and a network port. We do that by creating input channels for the console and the network port.

\begin{lstlisting}
let console_channel = console_input () in
let port_channel = port_input 9000 in
\end{lstlisting}

Using the channels, we can create signals that represent the input from the console and the network port.

\begin{lstlisting}
let console_in = mkSig_of_channel console_channel in
let port_in = mkSig_of_channel port_channel in
\end{lstlisting}

If we simply wanted to output the input signals directly to the console, we would only need to use the \texttt{console\_outputL} function to output the signals values. \texttt{console\_outputL} takes a later signal as input, where the L indicates that the signal is of a later type.

\begin{lstlisting}
console_outputL (console_in);
console_outputL (port_in);
\end{lstlisting}

However, to demonstrate the use of the map signal combinator in Rizzo, We will map the input to a new string with a prefix, before outputting them to the console. The \texttt{mapL} combinator takes a function and a later signal as input, and produces a new later signal where the function has been applied to each value of the input signal.

\begin{lstlisting}
console_outputL (mapL (fun s -> "From console: " ^ s) console_in);
console_outputL (mapL (fun s -> "From port: " ^ s) port_in);
\end{lstlisting}

Given we have not made a client that writes to the port, the port output will not produce any output, so lets fix that by taking the input from the console and writing it to the port as well. We can use the \texttt{port\_outputL} function from the \texttt{Channel} module to output to the port.

\begin{lstlisting}
port_outputL Unix.inet_addr_loopback 9000 console_in;
\end{lstlisting}

To block the main thread so the program does not exit, we call \lstinline{start_event_loop ();} at the end of the program.

An example interaction with the program so far could look like this:

\begin{verbatim}
Hello Rizzo
From console: Hello Rizzo
From port: Hello Rizzo
Hello again
From console: Hello again
From port: Hello again
\end{verbatim}

This was quite a simple program, but to show some more of Rizzo's capabilities, we can extend the program a bit further. Good examples of signal combinators are \texttt{filter} and \texttt{sample}.
The data flow for the extended program is visualized in Figure~\ref{fig:rizzo_flow}.

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.8\textwidth]{images/RizzoFlow.png}
  \caption{Data flow in Rizzo: from channels (circles) through signal combinators (boxes) to outputs (diamonds). The container represents user space, while the surrounding area represents the Rizzo runtime.}\label{fig:rizzo_flow}
\end{figure}

The \texttt{filter} function takes a predicate function and a signal as input, and produces a new signal that only contains values that satisfy the predicate. 

We could for example filter the console input signal to only contain values where the string equals `time'.

\begin{lstlisting}
let time_filter = filterL (fun s -> s = "time") console_in in
\end{lstlisting}

The \texttt{sample} function on the other hand, takes two signals, and produces a new signal that contains the tuple values from both signals whenever the first signal produces a value.

We could for example sample a clock signal that ticks every second with the filtered console signal.

To make a clock signal that ticks every second, we can use the \texttt{clock\_signal} function from the \texttt{Channel} module.

\begin{lstlisting}
let every_second, every_second_stop = clock_signal 1.0 in
let start_time = head every_second in
let sampled_console = sampleL time_filter every_second in
\end{lstlisting}

The \texttt{every\_second\_stop} value is a function that can be called to stop the clock signal when it is no longer needed. This mostly applies to long running programs that need to clean up resources when they exit.

We can then output the sampled console signal to the console, prepending a string to the output values.

\begin{lstlisting}
let formatted =
  (mapL (fun (_, f) -> string_of_float (f -. start_time))
    sampled_console) in
console_outputL formatted;
\end{lstlisting}

This will now output the time in seconds since the program started whenever the user inputs `time' in the console.

The full example program can be seen in Appendix~\ref{appendix:extended_example_program}.

\subsection{Functions and types}

For the reader's convenience while reading, this subsection can be used as a reference to understand the channel and signal APIs provided by Rizzo. Below is a list of the most notable functions provided by Rizzo. The channel and signal type definitions can be found in Section~\ref{section:implementing_rizzo} as Listings~\ref{listing:channel_type} and~\ref{listing:signal_type} respectively.

Notable channel and signal functions:
\begin{lstlisting}[caption={Notable channel and signal functions},label={listing:notable_signal_and_channel_functions},basicstyle=\linespread{0.8}\ttfamily\small]
(* Channel functions *)
val new_channel : unit -> 'a channel
val clock_channel : float -> float channel * (unit -> unit)

val never : 'a later
val delay : (unit -> 'a) -> 'a delayOnce
val adv : 'a delayOnce -> 'a
val app : ('a -> 'b) delayOnce -> 'a later -> 'b later
val sync: 'a later -> 'b later -> ('a, 'b) sync later
val wait : 'a channel -> 'a later
val trig : 'a option signal -> 'a later
val tail : 'a signal -> 'a signal later
val (|>>) : 'a later -> ('a -> 'b) -> 'b later

(* Signal functions *)
val mkSig : 'a later -> 'a signal later
val mkSig_of_channel : 'a channel -> 'a signal later
val clock_signal : float -> float signal * (unit -> unit)

val head : 'a signal -> 'a
val map : ('a -> 'b) -> 'a signal -> 'b signal
val zip : 'a signal -> 'b signal -> ('a * 'b) signal
val switch : 'a signal -> 'a signal later -> 'a signal
val switchS : 'a signal -> ('a -> 'a signal) later -> 'a signal
val switchR : 'a signal -> (('a -> 'a signal) signal) later -> 'a signal
val sample : 'a signal -> 'b signal -> ('a * 'b) signal
val scan : ('b -> 'a -> 'b) -> 'b -> 'a signal -> 'b signal
val interleave  : ('a -> 'a -> 'a) -> 'a signal -> 'a signal -> 'a signal
val filter : ('a -> bool) -> 'a signal later -> 'a signal later
val filter_map : ('a -> 'b option) -> 'a signal later -> 'b signal later
val triggerL : ('a -> 'b -> 'c) -> 'a signal later -> 'b signal -> 'c signal later

(* Output functions *)
val console_output : string signal -> unit
val console_outputL: string signal later -> unit
val port_outputL : Unix.inet_addr -> int -> string signal later -> unit
val set_quit : 'a signal later -> unit
val start_event_loop : unit -> unit
\end{lstlisting}
