\section{Using Rizzo}\label{using_rizzo}
%user space, examples of how to use it?
%Input channels : Clock signals, console signal,
%Output "channels":

This section gives a practical overview of how Rizzo can be used to build functional reactive programs. We explain (1) how to create input signals, (2) how to transform them using signal combinators, and (3) how to connect signals to outputs. We then combine these pieces in a small example program, and finish with a short reference of the most important functions and types in Section~\ref{section:functions_and_types}.

\subsection{Inputs}
%Lead with the positive! we are the best B)
Input sources in Rizzo are called \emph{channels}. The library currently provides channels for console input, timers, and network ports, but in principle a channel could be defined for any input source.

To use an input channel, you first obtain a channel from Rizzo, and then turn it into a signal. For example, below we create a signal that represents lines read from the console.

\begin{lstlisting}
open Rizzo
let console_channel = Channel.console_input () in
let console_signal = Signal.mkSig_of_channel console_channel
\end{lstlisting}

Most input constructors produce a value of type \texttt{'a signal later}, meaning the signal becomes available one step later (after the runtime observes an event). If the user wanted to make a signal with an initial value available immediately, they could use \texttt{Signal.init\_signal} instead. Which takes a channel and an initial value as arguments.

\begin{lstlisting}
let initialized_signal = Signal.init_signal console_channel "Initial value"
\end{lstlisting}

\subsection{Signal combinators}
Signals are the main abstraction in Rizzo, and the library provides a number of combinators for transforming them. Some of the most common ones are \texttt{map}, \texttt{filter}, and \texttt{sample}.

\begin{itemize}
  \item \texttt{map}: applies a function to each value produced by a signal.
  \item \texttt{filter}: keeps only the values that satisfy a predicate.
  \item \texttt{sample}: when the first signal produces a value, it emits a pair consisting of that value and the current value of the second signal.
\end{itemize}

\paragraph{A note on \texttt{later} and the \texttt{L} suffix.}
Since most signals do not make sence to create with initial values, they are often of type \texttt{'a signal later} (see Section~\ref{section:rizzo_later} for details in the later type).
Most combinators (and output functions) therefore come in two variants: one for plain signals and one for later signals, indicated by an \texttt{L} suffix (e.g., \texttt{map} vs.\ \texttt{mapL}). Intuitively, the \texttt{\underline{\hspace{0.5cm}}L} variant lets you build pipelines, without having to manually understand how to delay a signal to later, and makes the code more concise.

\subsection{Outputs}
Rizzo provides output functions that connect signals to output sinks. Currently, the library supports console output and network port output. As with combinators, there are typically two variants: one for plain signals and one for later signals (\texttt{...L}). Unlike combinators, output functions do not produce a new signal; they perform a side effect whenever the input signal produces a value.

\subsection{Example program}\label{section:rizzo_example}

To give some insight into how Rizzo can be used, we will in this section present a small example program that uses Rizzo to implement a simple interactive application. We start simple, by having the application read input from the console and a network port, and output the input to the console and network port.

First we open the the Rizzo modules we will use:

\begin{lstlisting}
open Rizzo.Types
open Rizzo.Signal
open Rizzo.Channel
\end{lstlisting}

Now that we have access to the Rizzo modules, we can start implementing our application. The application will need to read input from the console and a network port. We do that by creating input channels for the console and the network port.

\begin{lstlisting}
let console_channel = console_input () in
let port_channel = port_input 9000 in
\end{lstlisting}

Using the channels, we create two input signals:

\begin{lstlisting}
let console_in = mkSig_of_channel console_channel in
let port_in = mkSig_of_channel port_channel in
\end{lstlisting}

If we want to output the raw inputs, we can use \texttt{console\_outputL}. The \texttt{L} indicates that it expects a value of type \texttt{signal later}:

\begin{lstlisting}
console_outputL console_in;
console_outputL port_in;
\end{lstlisting}

However, to demonstrate \texttt{map}, we can prefix the incoming strings before printing them:

\begin{lstlisting}
console_outputL (mapL (fun s -> "From console: " ^ s) console_in);
console_outputL (mapL (fun s -> "From port: " ^ s) port_in);
\end{lstlisting}

Since we have not created a client that writes to the port, the port input may remain silent. To make this interaction visible, we can forward console input to the port using \texttt{port\_outputL}:

\begin{lstlisting}
port_outputL Unix.inet_addr_loopback 9000 console_in;
\end{lstlisting}

Finally, we call \lstinline{start_event_loop ();} to prevent the program from exiting.

An example interaction with the program so far could look like this:

\begin{verbatim}
Hello Rizzo
From console: Hello Rizzo
From port: Hello Rizzo
Hello again
From console: Hello again
From port: Hello again
\end{verbatim}

This was quite a simple program, but to show some more of Rizzo's capabilities, we can extend the program a bit further. Good examples of signal combinators are \texttt{filter} and \texttt{sample}.
The data flow for the extended program is visualized in Figure~\ref{fig:rizzo_flow}.

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.8\textwidth]{images/RizzoFlow.png}
  \caption{Data flow in Rizzo: from channels (circles) through signal combinators (boxes) to outputs (diamonds). The container represents user space, while the surrounding area represents the Rizzo runtime.}\label{fig:rizzo_flow}
\end{figure}

The \texttt{filter} function takes a predicate function and a signal as input, and produces a new signal that only contains values that satisfy the predicate. 

We could for example filter the console input signal to only contain values where the string equals `time'.

\begin{lstlisting}
let time_filter = filterL (fun s -> s = "time") console_in in
\end{lstlisting}

The \texttt{sample} function on the other hand, takes two signals, and produces a new signal that contains the tuple values from both signals whenever the first signal produces a value.

We could for example sample a clock signal that ticks every second with the filtered console signal.

To make a clock signal that ticks every second, we can use the \texttt{clock\_signal} function from the \texttt{Channel} module.

\begin{lstlisting}
let every_second, every_second_stop = clock_signal 1.0 in
let start_time = head every_second in
let sampled_console = sampleL time_filter every_second in
\end{lstlisting}

The \texttt{every\_second\_stop} value is a function that can be called to stop the clock signal when it is no longer needed. This mostly applies to long running programs that need to clean up resources when they exit.

We can then output the sampled console signal to the console, prepending a string to the output values.

\begin{lstlisting}
let formatted =
  (mapL (fun (_, f) -> string_of_float (f -. start_time))
    sampled_console) in
console_outputL formatted;
\end{lstlisting}

This will now output the time in seconds since the program started whenever the user inputs `time' in the console.

The full example program can be seen in Appendix~\ref{appendix:extended_example_program}.

\subsection{Functions and types}\label{section:functions_and_types}

For the reader's convenience while reading, this subsection can be used as a reference to understand the channel and signal APIs provided by Rizzo. Below is a list of the most notable functions provided by Rizzo. The channel and signal type definitions can be found in Section~\ref{section:implementing_rizzo} as Listings~\ref{listing:channel_type} and~\ref{listing:signal_type} respectively.

Notable channel and signal functions:
\begin{lstlisting}[caption={Notable channel and signal functions},label={listing:notable_signal_and_channel_functions},basicstyle=\linespread{0.8}\ttfamily\small]
(* Channel functions *)
val new_channel : unit -> 'a channel
val clock_channel : float -> float channel * (unit -> unit)

val never : 'a later
val delay : (unit -> 'a) -> 'a delayOnce
val adv : 'a delayOnce -> 'a
val app : ('a -> 'b) delayOnce -> 'a later -> 'b later
val sync: 'a later -> 'b later -> ('a, 'b) sync later
val wait : 'a channel -> 'a later
val trig : 'a option signal -> 'a later
val tail : 'a signal -> 'a signal later
val (|>>) : 'a later -> ('a -> 'b) -> 'b later

(* Signal functions *)
val mkSig : 'a later -> 'a signal later
val mkSig_of_channel : 'a channel -> 'a signal later
val init_signal : 'a channel -> 'a -> 'a signal
val clock_signal : float -> float signal * (unit -> unit)

val head : 'a signal -> 'a
val map : ('a -> 'b) -> 'a signal -> 'b signal
val mapL : ('a -> 'b) -> 'a signal later -> 'b signal later
val zip : 'a signal -> 'b signal -> ('a * 'b) signal
val switch : 'a signal -> 'a signal later -> 'a signal
val switchS : 'a signal -> ('a -> 'a signal) later -> 'a signal
val switchR : 'a signal -> (('a -> 'a signal) signal) later -> 'a signal
val sample : 'a signal -> 'b signal -> ('a * 'b) signal
val sampleL : 'a signal later -> 'b signal -> ('a * 'b) signal later
val scan : ('b -> 'a -> 'b) -> 'b -> 'a signal -> 'b signal
val interleave  : ('a -> 'a -> 'a) -> 'a signal -> 'a signal -> 'a signal
val filter : ('a -> bool) -> 'a signal later -> 'a signal later
val filterL : ('a -> bool) -> 'a signal later -> 'a signal later
val filter_map : ('a -> 'b option) -> 'a signal later -> 'b signal later
val triggerL : ('a -> 'b -> 'c) -> 'a signal later -> 'b signal -> 'c signal later

(* Output functions *)
val console_output : string signal -> unit
val console_outputL: string signal later -> unit
val port_outputL : Unix.inet_addr -> int -> string signal later -> unit
val set_quit : 'a signal later -> unit
val start_event_loop : unit -> unit
\end{lstlisting}
