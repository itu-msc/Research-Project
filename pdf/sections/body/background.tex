\section{Using Rizzo} \label{using_rizzo}
%user space, examples of how to use it?
%Input channels : Clock signals, console signal, 
%Output "channels":

This section will give an overview of how Rizzo can be used to implement functional reactive programs. We will go through how to create input signals, use signal combinators to manipulate the signals, and how to output the signals. We then combine the three, and show an example program that uses Rizzo to implement a simple interactive application.
We then finish the section with a list of the most notable functions and types provided by Rizzo.

\subsection{Inputs}
Input sources in Rizzo are called channels. There can theoretically be implemented an input channel for any kind of input source, but currently Rizzo only has a console, clock and port input implementation.

To use one of the input channels, the user requests to get one of the channels from Rizzo, and then uses the channel to create signals. For example, bellow we show how a console input channel can be used to create a signal that represents the input from the console.

\begin{lstlisting}
open Rizzo
let console_channel = Channel.console_input () in
let console_signal = Signal.mkSig_of_channel console_channel
\end{lstlisting}

\subsection{Signal combinators}
Signals are the bread and butter of Rizzo, and Rizzo provides a number of signal combinators that can be used to manipulate signals. Some of the most notable signal combinators are \texttt{map}, \texttt{filter} and \texttt{sample}. Signal combinators come in two variants, the normal variant that works on regular signals, and the later variant that works on later signals. The later variant is denoted by appending an L to the name of the combinator.

A brief overview of the signal combinators is given below:
\begin{itemize}
  \item \texttt{map}: Takes a function and a signal as input, and produces a new signal where the function has been applied to each value of the input signal.
  \item \texttt{filter}: Takes a predicate function and a signal as input, and produces a new signal that only contains values that satisfy the predicate.
  \item \texttt{sample}: Takes two signals as input, and produces a new signal that contains the tuple values from both signals whenever the first signal produces a value.
\end{itemize}

\subsection{Outputs}
Rizzo provides output functions that can be used to output signals to various output sources. Currently Rizzo has output functions for console and network port outputs. Like the signal combinators there can be two variants, one for regular signals and one for later signals. Unlike the signal combinators, the output functions do not produce a new signal, but instead have the side effect of outputting the signal values to the output source.

\subsection{Example program}\label{section:rizzo_example}

To give some insight into how Rizzo can be used, we will in this section present a small example program that uses Rizzo to implement a simple interactive application. The application will read input from the console and a network port, and will output values to the console and the network port based on the input it receives.

First we need to open the Rizzo modules that we will use in our program. In this case we will use the \texttt{Types}, \texttt{Signal} and \texttt{Channel} modules.

\begin{lstlisting}
open Rizzo.Types
open Rizzo.Signal
open Rizzo.Channel
\end{lstlisting}

Now that we have access to the Rizzo modules, we can start implementing our application. The application will need to read input from the console and a network port. We do that by creating input channels for the console and the network port.

\begin{lstlisting}
let console_channel = console_input () in
let port_channel = port_input 9000 in
\end{lstlisting}

Using the channels, we can create signals that represent the input from the console and the network port.

\begin{lstlisting}
let console_in = mkSig_of_channel console_channel in
let port_in = mkSig_of_channel port_channel in
\end{lstlisting}

If we simply wanted to output the input signals directly to the console, we would only need to use the \texttt{console\_outputL} function to output the signals values. \texttt{console\_outputL} takes a later signal as input, where the L indicates that the signal is of a later type.

\begin{lstlisting}
console_outputL (console_in);
console_outputL (port_in);
\end{lstlisting}

However, to demonstrate the use of the map signal combinator in Rizzo, We will map the input to a new string with a prefix, before outputting them to the console. The \texttt{mapL} combinator takes a function and a later signal as input, and produces a new later signal where the function has been applied to each value of the input signal.

\begin{lstlisting}
console_outputL (mapL (fun s -> "From console: " ^ s) console_in);
console_outputL (mapL (fun s -> "From port: " ^ s) port_in);
\end{lstlisting}

Given we have not made a client that writes to the port, the port output will not produce any output, so lets fix that by taking the input from the console and writing it to the port as well. We can use the \texttt{port\_outputL} function from the \texttt{Channel} module to output to the port.

\begin{lstlisting}
port_outputL Unix.inet_addr_loopback 9000 console_in;
\end{lstlisting}

To block the main thread so the program does not exit, we call \lstinline{start_event_loop ();} at the end of the program.

An example interaction with the program so far could look like this:

\begin{verbatim}
Hello Rizzo
From console: Hello Rizzo
From port: Hello Rizzo
Hello again
From console: Hello again
From port: Hello again
\end{verbatim}

This was quite a simple program, but to show some more of Rizzo's capabilities, we can extend the program a bit further. Good examples of signal combinators are \texttt{filter} and \texttt{sample}.
The data flow for the extended program can be visualized in Figure~\ref{fig:rizzo_flow}. The inputs are represented by circles at the top, the signal combinators by boxes in the middle, and the outputs by diamonds at the bottom. The container in the middle represents the user space where users can manipulate signals using Rizzo's signal combinators, while the area outside the container represents the Rizzo runtime that handles input channels and output signals.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth]{images/RizzoFlow.png}
  \caption{Data flow in Rizzo: from channels through signals to output.}\label{fig:rizzo_flow}
\end{figure}

The \texttt{filter} function takes a predicate function and a signal as input, and produces a new signal that only contains values that satisfy the predicate. 

We could for example filter the console input signal to only contain values where the string equals `time'.

\begin{lstlisting}
let time_filter = filterL (fun s -> s = "time") console_in in
\end{lstlisting}

The \texttt{sample} function on the other hand, takes two signals, and produces a new signal that contains the tuple values from both signals whenever the first signal produces a value.

We could for example sample a clock signal that ticks every second with the filtered console signal.

To make a clock signal that ticks every second, we can use the \texttt{clock\_signal} function from the \texttt{Channel} module.

\begin{lstlisting}
let every_second, every_second_stop = clock_signal 1.0 in
let start_time = head every_second in
let sampled_console = sampleL time_filter every_second in
\end{lstlisting}

The \texttt{every\_second\_stop} value is a function that can be called to stop the clock signal when it is no longer needed. This mostly applies to long running programs that need to clean up resources when they exit.

We can then output the sampled console signal to the console, prepending a string to the output values.

\begin{lstlisting}
let formatted =
  (mapL (fun (_, f) -> string_of_float (f -. start_time))
    sampled_console) in
console_outputL formatted;
\end{lstlisting}

This will now output the time in seconds since the program started whenever the user inputs `time' in the console.

The full example program can be seen in Appendix~\ref{appendix:extended_example_program}.

\subsection{Functions and types}

For the reader's convenience while reading, this subsection can be used as a reference to understand the channel and signal APIs provided by Rizzo. Below is a list of the most notable functions provided by Rizzo. The channel and signal type definitions can be found in Section~\ref{section:implementing_rizzo} as Listings~\ref{listing:channel_type} and~\ref{listing:signal_type} respectively.

Notable channel and signal functions:
\begin{lstlisting}[caption={Notable channel and signal functions},label={listing:notable_signal_and_channel_functions},basicstyle=\linespread{0.8}\ttfamily\small]
(* Channel functions *)
val new_channel : unit -> 'a channel
val clock_channel : float -> float channel * (unit -> unit)

val never : 'a later
val delay : (unit -> 'a) -> 'a delayOnce
val adv : 'a delayOnce -> 'a
val app : ('a -> 'b) delayOnce -> 'a later -> 'b later
val sync: 'a later -> 'b later -> ('a, 'b) sync later
val wait : 'a channel -> 'a later
val trig : 'a option signal -> 'a later
val tail : 'a signal -> 'a signal later
val (|>>) : 'a later -> ('a -> 'b) -> 'b later

(* Signal functions *)
val mkSig : 'a later -> 'a signal later
val mkSig_of_channel : 'a channel -> 'a signal later
val clock_signal : float -> float signal * (unit -> unit)

val head : 'a signal -> 'a
val map : ('a -> 'b) -> 'a signal -> 'b signal
val zip : 'a signal -> 'b signal -> ('a * 'b) signal
val switch : 'a signal -> 'a signal later -> 'a signal
val switchS : 'a signal -> ('a -> 'a signal) later -> 'a signal
val switchR : 'a signal -> (('a -> 'a signal) signal) later -> 'a signal
val sample : 'a signal -> 'b signal -> ('a * 'b) signal
val scan : ('b -> 'a -> 'b) -> 'b -> 'a signal -> 'b signal
val interleave  : ('a -> 'a -> 'a) -> 'a signal -> 'a signal -> 'a signal
val filter : ('a -> bool) -> 'a signal later -> 'a signal later
val filter_map : ('a -> 'b option) -> 'a signal later -> 'b signal later
val triggerL : ('a -> 'b -> 'c) -> 'a signal later -> 'b signal -> 'c signal later

(* Output functions *)
val console_output : string signal -> unit
val console_outputL: string signal later -> unit
val port_outputL : Unix.inet_addr -> int -> string signal later -> unit
val set_quit : 'a signal later -> unit
val start_event_loop : unit -> unit
\end{lstlisting}

\section{Implementing Rizzo} \label{section:implementing_rizzo}

Rizzo is implemented in \texttt{OCaml}, because it has weak references, generalized algebraic data types (GADTs) and a strong type system. We could potentially have better performance if we chose a language with reference counting, but OCaml is a good trade-off between performance and expressiveness.
We have implemented Rizzo as a library, where we have drawn a line between the core implementation and the user space. The intention with making this distinction is \texttt{if users follow our APIs}, then they will get the safety guarantees that Rizzo was designed for. If they don't, they could potentially break the guarantees Rizzo provides, by for example introducing side effects. As an OCaml library we cant guarantee that users will not introduce side effects, so we have to trust that they will follow the APIs.

Most of the implementation of Rizzo is contained in the \texttt{internals} module, which contains the core implementation of Rizzo. The \texttt{types} module contains the type definitions and type constructors used in Rizzo, and the \texttt{signal} and \texttt{channel} modules contain the signal combinators and channel implementations respectively. We have not hidden this implementation behind an abstract interface, since we want users to be able to extend Rizzo with new functionality if they want to. So input channels can for example be extended by users to support new input sources.

\todo{add stuff about space/time leaks}

\subsection{Channels}
Channels are input sources to Rizzo programs, they are controlled by the Rizzo runtime, and provided to the user through the Rizzo Channel module.
Channels produce input events at discrete time steps. All channels in Rizzo share a single global clock, where each tick of the clock represents a discrete time step at which channels may produce input events.

Internaly, the channel type is an index that identifies the channel. We incriment the index for each new channel created, so each channel has a unique index. But from the user's perspective, channels are opaque types that can only be created using the Rizzo Channel module.

\begin{lstlisting}[caption={The channel type definition},label={listing:channel_type}]
type 'a channel = Index of int
\end{lstlisting}


\subsection{The delayOnce type}
\todo{I need a bit of help here, what exactly is it used for exept for helping us with not evaluating values and functions too early? ie given we dont have call-by-name in ocaml, this is just a thunk wrapper right?}
The delayOnce type is used to represent values that will be available at the next time step. This is useful when we have a function that we want to pass, but we don't want to evaluate the function until the next time step. 

delayOnce is implemented as a wrapper around a thunk, which is a function that takes no arguments and returns a value. The thunk is only evaluated when the value is needed, which is at the next time step.

\subsection{The Later type}
The Later type is used to represent values that will be available at a later time step. In contrast to delayOnce, the Later type does not guarantee that the value will be available at the next time step, but only at some later time step. For example, using a filter on a signal will produce a signal that does not guarantee a value at the next time step, since the filter may not pass any values through.

We can for example make a later signal from a filter that never passes any values through, resulting in a later signal that never produces any values.

\begin{lstlisting}[caption={Creating a later signal that never produces any values},label={listing:never_signal}]
let never_signal = filterL (fun _ -> false) some_input_signal in
\end{lstlisting}

The internal type signature of Later is a GADT

\begin{lstlisting}[caption={The later type definition},label={listing:later_type}]
type _ later =
  | Never
  | App : ('a -> 'b) delayOnce * 'a later -> 'b later   (* this is the O>*)
  | Sync : 'a later * 'b later -> ('a, 'b) sync later
  | Wait : 'a channel -> 'a later
  | Trig : 'a option signal -> 'a later
  | Tail : 'a signal -> 'a signal later
...
\end{lstlisting}

\subsection{Signals}
Signals are the core concept in Rizzo, and represent time-varying values. Signals can be constructed from channels, or from other signals using signal combinators.
Signals are implemented as an infinite sequence, with the head being the current value of the signal, and the tail being a new later signal of the same type.

\begin{lstlisting}[caption={The signal type definition},label={listing:signal_type}]
type _ later =  
...
and 'a signal_data = { 
  id: int; 
  mutable head: 'a;
  mutable tail: 'a signal later;
  mutable updated: bool
}

and 'a signal = SignalID of 'a signal_data
\end{lstlisting}

For a reader unfamiliar with FRP, signals can be considered to be pipes where values flow through the network and ends up at output signals.


% \clearpage

% \subsection{A simpler processor model}\label{processor-model}
