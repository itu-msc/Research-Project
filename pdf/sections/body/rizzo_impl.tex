\section{Implementing Rizzo}\label{section:implementing_rizzo}

Rizzo is implemented in OCaml, because it has generalized algebraic data types (GADTs) to represent the \texttt{later} modality (Section~\ref{section:rizzo_later}), weak references for the heap representation (Section~\ref{section:rizzo_heap}), and a strong type system.

We have structured Rizzo as a library with a separation between the runtime implementation and the user space. The runtime is found in the \texttt{Rizzo.Internals} module while user-facing interface is provided through \texttt{Rizzo.Types}, \texttt{Rizzo.Signal}, and \texttt{Rizzo.Channel}. All of these are visible to users of the library. This separation allows users who limit themselves to the public interface to obtain the safety guarantees of Rizzo's design. At the same time, it allows users to extend the library with new functionality, such as new input sources, when needed.

As an OCaml library we cannot prevent users from abusing the interface or introducing arbitrary side effects. We note, that safety guarantees only hold when users following the public interface.

% Although Rizzo's design targets the absence of space leaks by construction, our implementation depends on OCaml's garbage collector (GC) to reclaim unused memory and does not enforce purity of user code. Within the intended usage of the public API, signals are updated in place and the heap stores only weak references, so discarded signals do not remain strongly reachable through the runtime.
% However, the timing of memory being reclaimed is controlled by the OCaml GC, which can leave short-lived \textit{ghost} heap entries. We mitigate the resulting effects by triggering a major GC cycle at the start of each time step.
