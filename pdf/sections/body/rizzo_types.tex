\subsection{Implementing the types of Rizzo}\label{section:rizzo_types}
Having already used the primitive types of Rizzo, this section formalises their meaning and explains how they are captured in OCaml.

\subsubsection{Channels}
Channels are input sources to Rizzo programs, they are controlled by the Rizzo runtime, and provided to the user through the Rizzo Channel module.
Channels produce input events at discrete time steps. All channels in Rizzo share a single global clock, where each tick of the clock represents a discrete time step at which channels may produce input events.

Internaly, the channel type is an index that identifies the channel. We incriment the index for each new channel created, so each channel has a unique index. But from the user's perspective, channels are opaque types that can only be created using the Rizzo Channel module.

\begin{lstlisting}[caption={The channel type definition},label={listing:channel_type}]
type 'a channel = Index of int
\end{lstlisting}


\subsubsection{The delayOnce type}
\todo{I need a bit of help here, what exactly is it used for exept for helping us with not evaluating values and functions too early? ie given we dont have call-by-name in ocaml, we need a thunk wrapper right, which is this?}
The delayOnce type is used to represent values that will be available at the next time step. This is useful when we have a function that we want to pass, but we don't want to evaluate the function until the next time step. 

delayOnce is implemented as a wrapper around a thunk, which is a function that takes no arguments and returns a value. The thunk is only evaluated when the value is needed, which is at the next time step.

\subsubsection{The Later type} \label{section:rizzo_later}
The Later type is used to represent values that will be available at a later time step. In contrast to delayOnce, the Later type does not guarantee that the value will be available at the next time step, but only at some later time step. For example, using a filter on a signal will produce a signal that does not guarantee a value at the next time step, since the filter may not pass any values through.

We can for example make a later signal from a filter that never passes any values through, resulting in a later signal that never produces any values.

\begin{lstlisting}[caption={Creating a later signal that never produces any values},label={listing:never_signal}]
let never_signal = filterL (fun _ -> false) some_input_signal in
\end{lstlisting}

The internal type signature of Later is a GADT

\begin{lstlisting}[caption={The later type definition},label={listing:later_type}]
type _ later =
  | Never
  | App : ('a -> 'b) delayOnce * 'a later -> 'b later   (* this is the O>*)
  | Sync : 'a later * 'b later -> ('a, 'b) sync later
  | Wait : 'a channel -> 'a later
  | Trig : 'a option signal -> 'a later
  | Tail : 'a signal -> 'a signal later
...
\end{lstlisting}

\subsubsection{Signals}
Signals are the core concept in Rizzo, and represent time-varying values. Signals can be constructed from channels, or from other signals using signal combinators.
Signals are implemented as an infinite sequence, with the head being the current value of the signal, and the tail being a new later signal of the same type.
A user might so far have imagined the signal type to be defined as:

\begin{lstlisting}[caption={A naive signal type definition},label={listing:naive_signal_type}]
type 'a signal = Sig of ('a * 'a signal later) ref
\end{lstlisting}

However, in the actual implementation signals must carry some additional information, a unique identifier and a flag indicating whether it has been updated. 
These fields are used by the runtime to manage signals, as explained in Section~\ref{section:rizzo_core}. 

The final internal representation of signals is shown in Listing~\ref{listing:signal_type}, where the record \texttt{signal\_data} has mutable \texttt{head} and \texttt{tail} fields, reflecting that signals are mutable references. 
As a final note, in the public interface (\texttt{Rizzo.Types}) the signal type is left opaque.

\begin{lstlisting}[caption={The signal type definition},label={listing:signal_type}]
type _ later =  
...
and 'a signal_data = { 
  id: int; 
  mutable head: 'a;
  mutable tail: 'a signal later;
  mutable updated: bool
}

and 'a signal = SignalID of 'a signal_data
\end{lstlisting}

% For a reader unfamiliar with FRP, signals can be considered to be pipes where values flow through the network and ends up at output signals.

