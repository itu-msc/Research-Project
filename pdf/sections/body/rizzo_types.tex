\subsection{Implementing the types of Rizzo}\label{section:rizzo_types}
Having already used the primitive types of Rizzo, this section formalises their meaning and explains how they are captured in OCaml.

\subsubsection{Channels}
Channels are input sources to Rizzo programs, they are controlled by the Rizzo runtime, and provided to the user through the Rizzo Channel module.
Channels produce input events at discrete time steps. 
%All channels in Rizzo share a single global clock, where each tick of the clock represents a discrete time step at which channels may produce input events.

Internaly, the channel type is an index that identifies the channel. We incriment the index for each new channel created, so each channel has a unique index. But from the user's perspective, channels are opaque types that can only be created using the Rizzo Channel module.

\begin{lstlisting}[caption={The channel type definition},label={listing:channel_type}]
type 'a channel = Index of int
\end{lstlisting}


\subsubsection{The delayOnce type}
The \texttt{delayOnce} type represents a computation whose result becomes available at the next time step. It is used to delay evaluation in a controlled way, to support guarded recursion.

In the implementation, \texttt{delayOnce} is a wrapper around a thunk (a function of type \texttt{unit -> \'a}). The thunk is forced only when advancing to the next time step and the value is required.

\subsubsection{The later type}\label{section:rizzo_later}
The \texttt{later} type represents a delayed computation, a promise that a value will become available at some future time step (or never). Such a promise is \emph{triggered} only when it is advanced by the reactive semantics (Section~\ref{section:rizzo_semantics}), and \emph{how} it triggers depends on the constructor: \texttt{Never} never triggers; \texttt{Wait} triggers when its channel produces an input; \texttt{Trig} triggers when the watched option-signal has a head of the form \texttt{Some}\,$A$; \texttt{Tail} triggers when the tail of the provided signal does; \texttt{App} triggers by applying a delayed function to a triggered argument; and \texttt{Sync} triggers when either side (or both) triggers.

To encode the later modality as a type it is necessary for \texttt{later} to be able to change and refine its element type. As an example consider the \texttt{App} constructor. It represents applying a delayed function ($(A \to B) \text{  delayOnce}$) to a delayed computation ($A \text{ later}$) and must there be able to produce a delayed computation of a different type ($B \text{ later}$). In order to capture this behaviour we need to model \texttt{later} as GADT which allows constructors such as $\texttt{App} : ((A \to B) \text{ delayOnce} \times A \text{ later}) \to B \text{ later}$.


%The Later type is used to represent values that will be available at a later time step. In contrast to delayOnce, the Later type does not guarantee that the value will be available at the next time step, but only at some later time step. For example, using a filter on a signal will produce a signal that does not guarantee a value at the next time step, since the filter may not pass any values through.
%We can for example make a later signal from a filter that never passes any values through, resulting in a later signal that never produces any values.

%\begin{lstlisting}[caption={Creating a later signal that never produces any values},label={listing:never_signal}]
%let never_signal = filterL (fun _ -> false) some_input_signal in
%\end{lstlisting}

\begin{lstlisting}[caption={The later type definition},label={listing:later_type}]
type _ later =
  | Never
  | App : ('a -> 'b) delayOnce * 'a later -> 'b later
  | Sync : 'a later * 'b later -> ('a, 'b) sync later
  | Wait : 'a channel -> 'a later
  | Trig : 'a option signal -> 'a later
  | Tail : 'a signal -> 'a signal later
...
\end{lstlisting}

\subsubsection{Signals}
Signals are the core concept in Rizzo, and represent time-varying values. Signals can be constructed from channels, or from other signals using signal combinators.
Signals are implemented as an infinite sequence, with the head being the current value of the signal, and the tail being a new later signal of the same type.
A user might so far have imagined the signal type to be defined as:

\begin{lstlisting}[caption={A naive signal type definition},label={listing:naive_signal_type}]
type 'a signal = Sig of ('a * 'a signal later) ref
\end{lstlisting}

However, in the actual implementation signals must carry some additional information, a unique identifier and a flag indicating whether it has been updated in the current time step. 
These fields are used by the runtime to manage signals, as explained in Section~\ref{section:rizzo_core}. 

The final internal representation of signals is shown in Listing~\ref{listing:signal_type}, where the record \texttt{signal\_data} has mutable \texttt{head} and \texttt{tail} fields, reflecting that signals are mutable references. 
As a final note, in the public interface (\texttt{Rizzo.Types}) the signal type is left opaque.

\begin{lstlisting}[caption={The signal type definition},label={listing:signal_type}]
type _ later =  
...
and 'a signal_data = { 
  id: int; 
  mutable head: 'a;
  mutable tail: 'a signal later;
  mutable updated: bool
}

and 'a signal = SignalID of 'a signal_data
\end{lstlisting}

% For a reader unfamiliar with FRP, signals can be considered to be pipes where values flow through the network and ends up at output signals.

