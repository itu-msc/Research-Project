\clearpage
\section{Conclusion}\label{section:conclusion}

This project demonstrates that the core ideas of Rizzo can be implemented as an embedded FRP library in OCaml. We implemented the main types, \texttt{delayOnce}, \texttt{later}, \texttt{channel} and \texttt{signal}, together with a runtime that instantiates Rizzo's reactive semantics by maintaining a global signal heap.

\paragraph{Summary of contributions.}
Our main contributions are:
(1) a type-safe OCaml implementation of Rizzo's delayed computations using GADTs.
(2) a runtime design that integrates multiple asynchronous input sources (console, timers, and ports) with the step semantics, by serializing heap updates under a mutex.
For the end user, the resulting API supports familiar combinators (\texttt{map}, \texttt{filter}, \texttt{sample}, \texttt{scan}, \texttt{switch}, etc.) while benefitting from Rizzo's key semantic improvements: signals update in place, which removes the need for a stable modality, while keeping well-behaved programs causal, productive, and absent of space leaks.

\paragraph{What the implementation taught us.}
A central outcome of the implementation is that implementing Rizzo in a garbage-collected language exposes runtime concerns that are not visible in the abstract model.
In particular, using weak references to signals ensures unused signals can be reclaimed by the GC\@. Weak references however in the combination with garbage collction, also introduce \emph{ghost} heap entries: nodes whose weak pointers have not yet been cleared by the garbage collector, even though the corresponding signals are no longer reachable from user code.
When combined with updating signals in place, these ghosts cause problems: advancing a tail may allocate a new signal, and overwrite an existing heap entry, causing the same work to be performed multiple times. In the presence of side effects, this can even duplicate effects.

Our implementation mitigates this issue by forcing a major GC cycle at the
beginning of each time step, removing unreachable signals and preventing ghost entries from accumulating. 

\paragraph{Limitations.}
The current implementation has a few limitations. First, forcing major GC can introduce nontrivial latency and makes the cost of each tick less predictable.
Secondly, the current execution model performs all reactive work on the input threads; as the heap grows, this can delay input handling (e.g.\ timer drift or back-pressure on I/O).
Finally, as a library we cannot enforce purity of user code, so the semantic guarantees only apply to users who stay within the intended usage fragment (i.e.\ who avoid observable side effects inside signal combinators).

\paragraph{Future work.}
There are several interesing directions for future work to address these limitations and further explore the design space:
\begin{enumerate}
    \item \textbf{Performance and allocation:} 
        benchmark heap traversal and advancement, and explore representations that reduce allocation during a time step.
        With the intention of reducing the performance impact of forcing garbage collection each time step.
    \item \textbf{Dedicated heap worker:} 
        investigate moving heap updates to a dedicated thread, decoupling input handling from signal updates to reduce input latency.
    \item \textbf{Channel resource management:} 
        improve channel lifecycle management (startup/shutdown, cleanup of threads and sockets) and clarify when resources are retained by outputs. For example, when should a channel be closed if its input is from a file?
    \item \textbf{API simplification and ergonomics:} 
        evaluate whether the public interface should expose channels directly or primarily expose signals, and whether \textit{later-heavy} APIs (or a uniform representation of inputs as delayed signals) can reduce cognitive overhead without obscuring essential timing behavior.
    \item \textbf{Testing and validation:} 
        develop property-based tests that exercise causality/productivity expectations at the library boundary, and construct microbenchmarks that isolate the \textit{ghost duplication} phenomenon to quantify the impact of different mitigations.
\end{enumerate}

% Overall, the implementation supports the thesis that Rizzo's can be implemented in a mainstream functional language. At the same time, our implementation highlights that an embedding must account for the host runtime, especially garbage collection and concurrency, to preserve the intended operational behavior in practice.
